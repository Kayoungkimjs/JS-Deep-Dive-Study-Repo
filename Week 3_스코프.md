# 스코프(scope)
- 스코프(유효범위)는 식별자가 유효한 범위
- 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)은 **자신이 선언된 위치**에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.
- 스코프 개념이 없다면 같은 이름을 갖는 변수는 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없다.
## 식별자 결정
- 식별자: 변수나 함수의 이름과 같은 식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름
- 자바스크립트 엔진이 어떤 변수를 참조해야 할 것인지를 결정하는 것 => 스코프는 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이다.
- 렉시컬 환경(lexical(어휘적, 사전적) environment): 코드가 어디서 실행되며 주변에 어떤 코드가 있는가. 즉 **코드의 문맥**은 렉시컬 환경으로 이뤄진다.
```javascript
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x); // -> local
}

foo();
console.log(x); // -> global
```
## 스코프의 종류
|구분|설명|스코프|변수|
|---|----------------|--------|-------|
|전역|코드의 가장 바깥 영역|전역 스코프|전역 변수(* 어디서든 유효)| 
|지역|함수 몸체 내부|지역 스코프|지역변수(*자신의 지역 스코프의 하위 지역 스코프에서 유효)|

## 스코프 체인(scope chain)
- 스코프가 계층적으로 연결된 것
- 모든 스코프는 하나의 계층적 구조로 연결, 모든 지역 스코프의 최상위 스코프는 전역 스코프다. 
- 자바스크립트 엔진은 코드를 실행하기 앞서 렉시컬 환경을 생성하고 -> 변수 선언이 실행되면 변수 식별자가 렉시컬 환경에 키로 등록 -> 변수 할당이 일어나면 변수 식별자에 해당하는 값을 변경한다.

## 전역, 함수, 블록 스코프
<img width="778" alt="스크린샷 2021-08-01 오후 2 46 59" src="https://user-images.githubusercontent.com/83155239/127760655-8fea52d1-3fe7-4f0c-856c-3b5ab7a40816.png">

# 전역 변수의 문제점
1. 암묵적 결합(implicit coupling)
- 모든 코드가 전역 변수를 참조하고 변경할 수 있음 -> 변수의 유효 범위가 클수록 코드의 가독성 떨어지고, 의도치 않게 상태가 변경될 수 있는 위험성 높아짐
2. 긴 생명 주기 : 생명 주기가 길어 메모리 리소스도 오랜 시간 소비함. (var는 변수 중복 선언이 가능해 의도치 않은 재할당이 이뤄진다)
3. 스코프 체인 상에서의 종점에 존재 : 전역 변수의 검색 속도가 가장 느림 -> 속도의 차이를 가져옴
4. 네임스페이스 오염 : 분리된 하나의 파일도 하나의 전역 스코프를 공유함 -> 다른 파일 내에서 동일한 이름으로 명명된 전역 변수/함수가 같은 스코프내에 존재할 경우 재앙..
!전역 변수의 무분별한 사용은 위험! 전역 변수를 반드시 사용해야 하지 않는다면 **지역 변수**를 사용해야 한다. 
## 변수의 생명주기 
- 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.
- 전역 코드는 명시적인 호출 없이 실행되고, 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다.
## 스코프와 호이스팅 
- 호이스팅은 스코프를 단위로 동작한다. 
- 전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프의 선두처럼 끌어 올려진 것처럼 동작하고, 
- 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작한다.
## 전역 변수 사용 억제하는 방법
1. 즉시 실행 함수: 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. ()
2. 네임스페이스 객체: 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 프로퍼티로 추가
```javascript
var MYAPP = {}; // 전역 네임스페이스 객체
MYAPP.name = 'Lee';
```
3. 모듈 패턴
- 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 방법 (클로저를 기반으로 동작, 캡슐화 구현 가능)
4. ES6 모듈 : 독파일 자체의 독자적인 모듈 스코프 제공 
```javascript
<script type="module" src="lib.mjs"></script>
```
# let, const 키워드와 블록 레벨 스코프
## var 키워드 변수의 문제점
- 변수 중복 선언 허용
- 함수 레벨 스코프에서 함수 코드 블록만을 지역 스코프로 인정, 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다. 
- 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작하면 가독성을 떨어뜨리고 오류를 발생시킬 수 있다.
## let 키워드
- 스코프 내에서 변수 중복 선언을 허용하지 않는다.
- 모든 코드 블록(함수, if, while..)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
```javascript
let foo = 1; //전역 변수

{
  let foo = 2; //지역 변수
  let bar = 3; //지역 변수
}

console.log(foo); // 1
console.log(bar); // referenceError: bar is not defined
```
- 변수 호이스팅이 발생하지 않는 것처럼 보이지만, 그렇지 않다. 
  - let 키워드로 선언한 변수는 '선언 단계'와 '초기화 단계'가 분리되어 진행된다. 
  - 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계 먼저 실행, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.
  - 스코프의 시작 ~ 초기화 단계 시작 시점(변수 선언문)까지 변수를 참조할 수 없다. => **일시적 사각지대(Temporal Dead Zone: TDZ)**
- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니고, 보이지 않는 개념적인 블록 내에 존재한다. 
## const 키워드
- let 특징과 대부분 동일
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다. (`const foo = 1;` / `const foo;` => error)
- 재할당 금지!
- 상수는 재할당이 금지된 변수로 상태 유지와 가독성, 유지보수의 편의를 위해 적극 사용한다. (상수의 이름은 대분자로 선언한다. `const TAX_RATE = 0.1;`)
- const 키워드로 선언된 변수에 **객체**를 할당할 경우 값을 변경할 수 있다.

# 프로퍼티 어트리뷰트
- 자바스크립트 엔진이 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 기본값
- 프로퍼티의 상태: 프로퍼티 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable) (**Object.getOwnPropertyDescriptor** 확인)
## 데이터 프로퍼티와 접근자 프로퍼티
- 데이터 프로퍼티: 키와 값으로 구성된 일반적 프로퍼티
- 접근자 프로퍼티: 자체적으로 값을 갖지 않도 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티 (**Get, Set**, Enumerable, Configurable)
  get-데이터 프로퍼티의 값을 **읽을 때** 호출되는 접근자 함수, set-데이터 프로퍼티의 값을 **저장할 때** 호출되는 접근자 함수 
## 프로퍼티 정의
- 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의 하는 것
- **Object.defineProperty** 메서드를 사용한다. (value, writable, enumerable, configurable) (여러개의 프로퍼티는 **Object.defineProperties**)
## 객체 변경 방지
- 객체는 변경 가능한 값이므로 재할당 없이 직접 변경 가능

| 구분           | 메서드                   | 프로퍼티  추가 | 삭제 | 값 읽기 | 값 쓰기 | 어트리뷰트 재정의 |
|----------------|--------------------------|----------------|------|---------|---------|-------------------|
| 객체 확장 금지 | Object.preventExtensions |        X       |   O  |    O    |    O    |         O         |
| 객체 밀봉      | Object.seal              |        X       |   X  |    O    |    O    |         X         |
| 객체 동결      | Object.freeze            |        X       |   X  |    O    |    X    |         X         |

# 생성자 함수에 의한 객체 생성
## Object 생성자 함수
- **new 연산자**와 **Objact 생성자 함수**를 호출하면 빈 객체를 생성하여 반환한다. 이후 프로퍼티, 메서드를 추가해 객체를 완성한다.
- 생성자 함수(constructor): 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수. 생성자 함수에 의해 생성된 객체 = 인스턴스(instance)
- String, Number, Function, Array, Date, RegExp, Promise 등 빌트인 생성자 함수 또한 제공 (`new String(''), new Number(), new Boolean..`)
- 객체 리터럴은 단 하나의 객체만 생성하기 때문에, 여러 개를 생성해야 하는 경우 생성자 함수를 쓰는 것이 효율적이다. 

# 일급 객체
1. 무명의 리터럴로 생성할 수 있다. (런타임에 생성이 가능하다)
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다. 

## 함수 객체의 프로퍼티
### arguments 
- 함수 객체의 arguments 프로퍼티 값은 arguments 객체. 
### caller : 함수 자신을 호출한 함수
### length
- 함수를 정의할 때 선언한 매게변수의 개수
- 객체는 인자의 개수, 함수 객체에서는 매개변수의 개수를 가리킨다.
### name
- 함수이름. ES5: 빈 문자열, ES6: 함수 객체를 가리키는 식별자
### __proto__접근자
- 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 슬롯이 가리키는 프로토타입 객체에 (간접적으로) 접근하기 위해 사용하는 접근자 프로퍼티
### prototype
- 생성자 함수로 호출할 수 있는 함수 객체, constructor만 소유하는 프로퍼티, 함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체
